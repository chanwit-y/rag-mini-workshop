## RecursiveCharacterTextSplitter

`RecursiveCharacterTextSplitter` เป็นหนึ่งในเครื่องมือแบ่งข้อความ (Text Splitter) ที่ **แนะนำให้ใช้เป็นตัวแรก** และเป็นที่นิยมมากที่สุดใน LangChain เพราะมันมีความยืดหยุ่นและทำงานได้ดีกับข้อความทั่วไปเกือบทุกประเภท

### 1. ทำไมเราต้องแบ่งข้อความ (Chunking)?

ก่อนจะไปดูว่า `RecursiveCharacterTextSplitter` ทำงานอย่างไร เราต้องเข้าใจปัญหาก่อนครับ

- **ข้อจำกัดของ Context Window:** LLM ไม่สามารถรับข้อความที่มีความยาวมากๆ ได้ในครั้งเดียว (เช่น เอกสาร 100 หน้า) เราจึงต้องซอยเอกสารเป็นชิ้นเล็กๆ (Chunks) ที่มีขนาดพอดีกับที่ LLM รับไหว
- **เพิ่มความแม่นยำในการค้นหา (Retrieval):** ในระบบ RAG การค้นหาข้อมูลจากชิ้นส่วนเล็กๆ ที่มีความหมายสมบูรณ์ในตัวเอง จะให้ผลลัพธ์ที่ดีกว่าการค้นหาจากเอกสารขนาดยักษ์

---

### 2. หัวใจการทำงาน: การแบ่งแบบ "ไล่ลำดับ" (Recursive)

ชื่อ "Recursive" มาจากวิธีการที่มันพยายามแบ่งข้อความ โดยมันจะ **ลองแบ่งตามลำดับของตัวคั่น (Separators) ที่กำหนดไว้ จากใหญ่ไปเล็ก**

โดยค่าเริ่มต้น (Default) มันจะใช้ลิสต์ของตัวคั่น (Separators) ดังนี้:

JavaScript

```ts
["\n\n", "\n", " ", ""]
```

**กระบวนการทำงานจะเป็นดังนี้:**

1. **พยายามแบ่งด้วย `\n\n` (ขึ้นย่อหน้าใหม่):** อันดับแรก มันจะพยายามหาจุดที่เป็นการขึ้นย่อหน้าใหม่ (double newlines) เพื่อแบ่งข้อความออกจากกัน เพราะนี่คือการแบ่งทางความหมายที่ใหญ่ที่สุด
2. **ถ้า Chunk ยังใหญ่ไป, พยายามแบ่งด้วย `\n` (ขึ้นบรรทัดใหม่):** หากชิ้นส่วนที่ได้จากขั้นตอนแรกยังยาวเกิน `chunk_size` ที่กำหนด มันจะพยายามซอยชิ้นส่วนนั้นๆ ให้เล็กลงอีกโดยใช้การขึ้นบรรทัดใหม่ (single newline)
3. **ถ้ายังใหญ่อีก, พยายามแบ่งด้วย (เว้นวรรค):** หากยังไม่ได้ขนาดที่ต้องการอีก มันจะเริ่มแบ่งด้วยการเว้นวรรค ซึ่งก็คือการพยายามแยกคำออกจากกัน
4. **ถ้าสุดทางแล้ว, แบ่งตามตัวอักษร (`""`):** ในกรณีสุดท้ายจริงๆ หากแม้แต่คำเดียวยังยาวเกิน `chunk_size` (ซึ่งเกิดได้ยาก) มันจะเริ่มหั่นตามจำนวนตัวอักษรเลย

**เปรียบเทียบง่ายๆ:** เหมือนเรากำลังพยายามตัดบทความยาวๆ ให้เป็นประโยคสั้นๆ ที่สมบูรณ์ เราจะเริ่มมองหาจุดจบของ "ย่อหน้า" ก่อน, ถ้าไม่มี ก็หาจุดจบของ "ประโยค" (เช่น .), ถ้าไม่มีอีก ก็หา "วลี" (เช่น ,) และสุดท้ายถ้าไม่มีอะไรเลย ก็คงต้องเริ่มนับคำเพื่อตัดแบ่ง

วิธีการนี้ทำให้มันพยายามรักษาความหมายของข้อความไว้ให้ได้มากที่สุด (Semantic Preservation) โดยจะพยายามแบ่งตรงจุดที่เป็นการแบ่งตามธรรมชาติของภาษาก่อนเสมอ

---

### 3. พารามิเตอร์ที่สำคัญ

คุณสามารถปรับแต่งการทำงานของมันผ่านพารามิเตอร์หลักๆ ได้แก่:

- `chunk_size`: ขนาดสูงสุดของแต่ละ Chunk ที่คุณต้องการ (นับเป็นจำนวนตัวอักษร)
    - **ตัวอย่าง:** ถ้าตั้ง `chunk_size: 200` มันจะพยายามสร้าง Chunks ที่มีความยาวไม่เกิน 200 ตัวอักษร
- `chunk_overlap`: จำนวนตัวอักษรที่จะให้ "ซ้อนทับกัน" ระหว่างสอง Chunks ที่อยู่ติดกัน
    - **ทำไมต้องมี Overlap?** เพื่อช่วยรักษาความหมายที่อาจจะคาบเกี่ยวกันระหว่างสอง Chunks เช่น ประโยคสุดท้ายของ Chunk ที่ 1 อาจจะเชื่อมโยงกับประโยคแรกของ Chunk ที่ 2 การมี Overlap ช่วยให้ LLM เห็นบริบทที่ต่อเนื่องกันได้
    - **ตัวอย่าง:**
        - `Chunk 1: [...ประโยคที่อาจจะยังไม่จบ]`
        - `Chunk 2: [ประโยคที่อาจจะยังไม่จบ และเนื้อหาต่อ...]`
        - ส่วนที่ซ้อนทับกัน (Overlap) จะช่วยให้ความหมายไม่ขาดตอน

---

### 4. ตัวอย่าง Code ใน TypeScript

นี่คือตัวอย่างการใช้งานจาก Presentation ที่เราทำไปครับ

TypeScript

```ts
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";

// สร้าง instance ของ splitter
const splitter = new RecursiveCharacterTextSplitter({
  chunkSize: 200,      // ขนาด Chunk สูงสุด 200 ตัวอักษร
  chunkOverlap: 20,     // ให้มีส่วนซ้อนทับกัน 20 ตัวอักษร
});

const text = "LangChain is an open-source framework for building applications with Large Language Models.\n\nIt provides tools for chaining together different components, such as models, prompts, and memory. The TypeScript version is called LangChain.js.";

// ทำการแบ่งข้อความ
const chunks = await splitter.splitText(text);

console.log(chunks);
```

**ผลลัพธ์ที่คาดหวัง:**

JSON

```
[
  "LangChain is an open-source framework for building applications with Large Language Models.",
  "It provides tools for chaining together different components, such as models, prompts, and memory. The TypeScript version is called LangChain.js."
]
```

ในตัวอย่างนี้ เนื่องจาก `\n\n` สามารถแบ่งข้อความออกเป็นสองส่วน และแต่ละส่วนมีความยาวไม่เกิน 200 ตัวอักษร มันจึงหยุดที่ขั้นตอนแรกและได้ผลลัพธ์เป็น 2 Chunks ที่สมบูรณ์

### สรุป

`RecursiveCharacterTextSplitter` คือเครื่องมือแบ่งข้อความที่ทรงพลังและยืดหยุ่น โดยมีหลักการคือ **พยายามแบ่งข้อความตามตัวคั่นที่เป็นธรรมชาติที่สุดก่อน (ย่อหน้า -> บรรทัด -> เว้นวรรค) เพื่อรักษาโครงสร้างและความหมายของประโยคไว้ให้ได้มากที่สุด** ทำให้มันเป็นตัวเลือกเริ่มต้นที่ดีเยี่ยมสำหรับงาน RAG ส่วนใหญ่